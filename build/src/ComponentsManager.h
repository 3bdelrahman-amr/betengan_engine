#pragma once
#include<unordered_map>
#include"SomeDef.h"
#include"GenericArrayOfComponent.h"
//#include<memory>
class ComponentsManager
{
private:
	
	unordered_map<const char*, Components> mComponentTypes{}; // map for all component has a unique ID
    unordered_map<const char*,   shared_ptr<AllComponents>> mComponentArrays{}; // MAp off Components Array
    Components mNextComponentType=0;// unique ID for every COmponent Array 
	
	//Function that Get Pointer to Array Of Component From the map That HAs Array Of Components
	// we declared it as private member because only member functions will access it
	template<typename T>
	shared_ptr< GenericArrayOfComponent<T> > GetComponentArray()
	{
		const char* typeName = typeid(T).name(); // typeid function is a c++ built in function that return unique pointer to the specific class
												 // here it return the class name as string that will help us to retreive Array of components from the map

		//assert(mComponentTypes.find(typeName) != mComponentTypes.end() && "Component not registered before use.");

		return static_pointer_cast<GenericArrayOfComponent<T>>(mComponentArrays[typeName]);
	}//static_c
//	make_shared
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////////////////////////////////////
public: 
	template<typename T>

void  RegisterComponent()

{
	const char* typeName = typeid(T).name();

	assert(mComponentTypes.find(typeName) == mComponentTypes.end());// here it checks if there is no Array of components exist before for the new Component

	mComponentTypes.insert({ typeName, mNextComponentType });
	mComponentArrays.insert({ typeName, std::make_shared<GenericArrayOfComponent<T>>() });
	mNextComponentType++;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
Components GetComponentType()
{
	const char* typeName = typeid(T).name();

	//assert(mComponentTypes.find(typeName) != mComponentTypes.end() && "Component not registered before use.");


	return mComponentTypes[typeName];
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// add component to the array of components that it is belongs to
template<typename T>
void AddComponent(Entity entity, T component)
{

	GetComponentArray<T>()->InsertData(entity, component);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////

template<typename T>
void RemoveComponent(Entity entity)
{

	GetComponentArray<T>()->RemoveData(entity);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename T>
T* GetComponent(Entity entity)
{
	// Get a reference to a component from the array for an entity
	return GetComponentArray<T>()->GetData(entity);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//this function checks if every component belongs to a destroyed entity still exist in every array of components will destroy them
void ComponentsManager::EntityDestroyed(Entity entity)
{

	for (auto const& pair : mComponentArrays)
	{
		auto const& component = pair.second;

		component->EntityDestroyed(entity);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////


};

